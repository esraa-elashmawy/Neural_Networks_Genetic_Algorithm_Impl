# -*- coding: utf-8 -*-
"""GA_for_sin.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yIMXcbt8pDDqB7ysjHgPgeXR7W9ilcjd
"""

import numpy
import matplotlib.pyplot
import math
import random

def cal_pop_fitness(pop):
 # Calculating the fitness value of each solution in the current population.
 fitness = numpy.sin((math.pi *pop)/256)
 return fitness

def select_mating_pool(pop, fitness, num_parents):
 #parents = numpy.empty(num_parents)
  parents=['' for x in range(num_parents)] 
  for parent_num in range(num_parents):
    max_fitness_idx = numpy.where(fitness == numpy.max(fitness))
    max_fitness_idx = max_fitness_idx[0][0]
    parents[parent_num] = pop[max_fitness_idx]
    fitness[max_fitness_idx] = -99999999999
  return parents

def int_to_bin(int_vals):
  binary_population=[]
  val=""
  for i in range(len(int_vals)):
    val=bin(int_vals[i])[2:]
    val=binary_to_gray_op(val)
    while len(val)<8 :
      val="0"+val
    binary_population.append(val) 

  return binary_population

def crossover(parents, offspring_size,type):
    offspring = ['' for x in range(offspring_size)] 
    if type=='50%':
    # The point at which crossover takes place between two parents. Usually, it is at the center.
      crossover_point = len(parents[0])//2
      #print(parents)
      for k in range(offspring_size):
          parent1_idx = k%len(parents)
          parent2_idx = (k+1)%len(parents) 
          offspring[k]=parents[parent1_idx][0:crossover_point] + parents[parent2_idx][crossover_point:]
    
    elif type=='one-point':
      point = random.randint(0, len(parents[0])-1)
      for k in range((offspring_size//2)):
          parent1_idx = k*2
          parent2_idx = parent1_idx +1
          offspring[parent1_idx]=parents[parent1_idx][0:point] + parents[parent2_idx][point:]
          offspring[parent2_idx]=parents[parent2_idx][0:point] + parents[parent1_idx][point:]

    elif type=='two-point':
      point1 = random.randint(0, len(parents[0])-1)
      point2 = random.randint(0, len(parents[0])-1)
    # print(point1,"$$",point2)
      for k in range((offspring_size//2)):
          parent1_idx = k*2
          parent2_idx = parent1_idx +1
          if point2>point1:
            offspring[parent1_idx]=parents[parent1_idx][:point1] + parents[parent2_idx][point1:point2] +parents[parent1_idx][point2:] 
            offspring[parent2_idx]=parents[parent2_idx][:point1] + parents[parent1_idx][point1:point2]+ parents[parent2_idx][point2:] 
          else:
            offspring[parent1_idx]=parents[parent2_idx][:point2] + parents[parent1_idx][point2:point1] +parents[parent2_idx][point1:] 
            offspring[parent2_idx]=parents[parent1_idx][:point2] + parents[parent2_idx][point2:point1]+ parents[parent1_idx][point1:]         

    return offspring

def mutation(offspring_crossover, mutation_prob):
    # Mutation changes a single gene in each offspring randomly.
    #number of genes that are going to be mutated:
    mutation_number=round(len(offspring_crossover)*mutation_prob)
    #print(mutation_number)
    mutation_gene_idxs=random.sample(range(0, len(offspring_crossover)), mutation_number)
    #print(mutation_gene_idxs)
    for idx in mutation_gene_idxs:
        # The random value to be added to the gene.
          random_value = random.randint(0,len(offspring_crossover[0])-1)
          if offspring_crossover[idx][random_value] =='1':
            new_gene=offspring_crossover[idx][:random_value] + "0" + offspring_crossover[idx][random_value+1:]
            new_gene=repair_function(0,255,int(new_gene, 2))
            offspring_crossover[idx]=bin(new_gene)[2:]
          else:
            new_gene=offspring_crossover[idx][:random_value] + "1" + offspring_crossover[idx][random_value+1:]
            new_gene=repair_function(0,255,int(new_gene, 2))
            offspring_crossover[idx]=bin(new_gene)[2:]

    return offspring_crossover

def repair_function(range1,range2,value):
  if value<range1 :
    value=range1
  if value>range2 :
    value=range2
  return value

def binary_to_gray_op(n):
   n = int(n, 2)
   n ^= (n >> 1)

   return bin(n)[2:]

def gray_to_binary(n):
    """Convert Gray codeword to binary and return it."""
    n = int(n, 2) # convert to int
 
    mask = n
    while mask != 0:
        mask >>= 1
        n ^= mask
    # bin(n) returns n's binary representation with a '0b' prefixed
    # the slice operation is to remove the prefix
    return bin(n)[2:]