# -*- coding: utf-8 -*-
"""sin_main.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XgQcXNTQbu4s7tjzcvWqTDA99_Go3kCS
"""

from google.colab import files
files.upload()

import ga_for_sin as ga_sin
import numpy

import numpy
sol_per_pop = 8 #x pop_per_sol=8
num_parents_mating = 4
pop_size = (sol_per_pop)

new_value_population = numpy.random.randint(255, size=pop_size)
print(new_value_population)
binary_population=[]
val=""
for i in range(len(new_value_population)):
  #new_pop[i]=bin(new_population[i])
  val=bin(new_value_population[i])[2:]
  while len(val)<8 :
    val="0"+val
  binary_population.append(val) 

print(binary_population)
print(len(binary_population))

def gray_to_binary(n):
    """Convert Gray codeword to binary and return it."""
    n = int(n, 2) # convert to int
 
    mask = n
    while mask != 0:
        mask >>= 1
        n ^= mask
    # bin(n) returns n's binary representation with a '0b' prefixed
    # the slice operation is to remove the prefix
    return bin(n)[2:]

num_generations = 15;
num_parents_mating = 4
AllMax=[];
for generation in range(num_generations):
   # Measuring the fitness of each chromosome in the population.
     fitness = ga_sin.cal_pop_fitness(new_value_population)
   # Selecting the best parents in the population for mating.
     parents = ga_sin.select_mating_pool(new_value_population, fitness,num_parents_mating)
   # Generating next generation using crossover.
     offspring_crossover = ga_sin.crossover(ga_sin.int_to_bin(parents), 4,"one-point")
   # Adding some variations to the offsrping using mutation.
     offspring_mutation = ga_sin.mutation(offspring_crossover,0.5)
     int_offspring_mutation=[]
     val=0
     for i in range(len(offspring_mutation)):
      val=ga_sin.gray_to_binary(offspring_mutation[i])
      val=int(val,2)
      int_offspring_mutation.append(val) 
     
  # Creating the new population based on the parents and offspring.
     new_value_population[0:len(parents)] = parents
     new_value_population[len(parents):] = int_offspring_mutation
     print(new_value_population);
  #must store the value that outputs the maximum fitness in each iteration 
     Allfitness = ga_sin.cal_pop_fitness(new_value_population)
     Maxfitness_idx=numpy.argmax(Allfitness)
    #  if new_value_population[Maxfitness_idx] >MaxVal:
    #    MaxVal=new_value_population[Maxfitness_idx]
     AllMax.append(new_value_population[Maxfitness_idx])

print(new_value_population);
print(AllMax)

import matplotlib.pyplot as plt
import numpy as np
ypoints = np.array([1, 2, 3, 4,5,6,7,8,9,10,11,12,13,14,15])

plt.plot(ypoints,AllMax)
plt.show()

"""The GA for 2nd objective function """

from google.colab import files
files.upload()

import ga_for_fn as ga2

import numpy
import random

sol_per_pop = (1000,2) #x pop_per_sol=8
num_parents_mating = 4
pop_size = (sol_per_pop)

new_value_population = numpy.random.uniform(low=-5.0, high=5.0, size=pop_size)

new_value_population

num_generations = 10;
num_parents_mating = 50
AllMin=[];
AllMinFitness=[];
for generation in range(num_generations):
   # Measuring the fitness of each chromosome in the population.
     fitness = ga2.cal_pop_fitness(new_value_population)
   # Selecting the best parents in the population for mating.
     parents = ga2.select_mating_pool(new_value_population, fitness,num_parents_mating)
   # Generating next generation using crossover.
     offspring_crossover = ga2.crossover(parents,offspring_size=(pop_size[0]-parents.shape[0], 2))
   # Adding some variations to the offsrping using mutation.
     offspring_mutation = ga2.mutation(offspring_crossover,0.5)
     
  # Creating the new population based on the parents and offspring.
     new_value_population[0:len(parents)] = parents
     new_value_population[len(parents):] = offspring_mutation
     #print(new_value_population);
  #must store the value that outputs the maximum fitness in each iteration 
     Allfitness = ga2.cal_pop_fitness(new_value_population)
     Minfitness_idx=numpy.argmin(Allfitness)
    #  if new_value_population[Maxfitness_idx] >MaxVal:
    #    MaxVal=new_value_population[Maxfitness_idx]
     AllMin.append(new_value_population[Minfitness_idx])
     AllMinFitness.append(min(Allfitness))

print(new_value_population);
print(AllMin)
print(AllMinFitness)

gen=[0 for x in range(len(AllMin))] 
for n in range(10):
  gen[n]=n+1

gen

import matplotlib.pyplot as plt
import numpy as np
ypoints = np.array([1, 2, 3, 4,5,6,7,8,9,10,11,12,13,14,15])

plt.plot(gen,AllMinFitness)
plt.show()